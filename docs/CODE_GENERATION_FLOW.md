# 代码生成完整流程文档

## 概述

本文档详细描述了零代码应用生成平台中，从用户输入到代码生成的完整流程，以及 LLM（大语言模型）在每个步骤中的核心作用。

---

## 一、整体架构

```
用户输入 → 请求处理 → AI 服务初始化 → LLM 代码生成 → 代码解析 → 代码保存 → 项目构建 → 返回结果
```

---

## 二、详细流程

### 阶段一：用户请求处理

**位置**：`AppServiceImpl.chatToGenCode()`

**流程步骤**：

1. **参数校验**
   - 验证 `appId` 和用户消息是否有效
   - 确保请求参数完整

2. **应用信息查询**
   - 从数据库查询应用信息
   - 获取应用的代码生成类型（HTML、MULTI_FILE、VUE_PROJECT）

3. **权限校验**
   - 验证用户是否有权限操作该应用
   - 确保用户只能操作自己创建的应用

4. **保存用户消息**
   - 将用户消息保存到数据库（`chat_history` 表）
   - 为后续对话历史加载做准备

5. **任务去重**
   - 使用 `GenerationTaskManager` 防止同一应用并发生成
   - 确保同一时间只有一个生成任务在执行

**LLM 作用**：此阶段 LLM 未参与，主要是业务逻辑处理。

---

### 阶段二：AI 服务初始化

**位置**：`AiCodeGeneratorServiceFactory.createAiCodeGeneratorService()`

**核心机制**：

#### 2.1 创建对话记忆（Chat Memory）

```java
MessageWindowChatMemory chatMemory = MessageWindowChatMemory
    .builder()
    .id(appId)  // 每个应用有独立的对话上下文
    .chatMemoryStore(redisChatMemoryStore)  // 使用 Redis 持久化
    .maxMessages(100)  // 最多保留 100 条历史消息
    .build();
```

**LLM 作用**：
- **上下文管理**：为每个应用创建独立的对话记忆，确保 LLM 能够理解多轮对话的上下文
- **历史加载**：从数据库加载历史对话到记忆，让 LLM 知道之前的对话内容
- **状态隔离**：不同应用的对话上下文互不干扰

#### 2.2 根据类型配置 LLM 服务

**Vue 项目模式**：
```java
AiServices.builder(AiCodeGeneratorService.class)
    .chatModel(chatModel)  // 基础对话模型
    .streamingChatModel(reasoningStreamingChatModel)  // 推理模型（支持工具调用）
    .chatMemoryProvider(memoryId -> chatMemory)  // 对话记忆
    .tools((Object[]) toolManager.getAllTools())  // 注册工具（FileWriteTool 等）
    .maxSequentialToolsInvocations(30)  // 最多连续调用 30 次工具
    .inputGuardrails(new PromptSafetyInputGuardrail())  // 输入安全检查
    .build();
```

**HTML/多文件模式**：
```java
AiServices.builder(AiCodeGeneratorService.class)
    .chatModel(chatModel)
    .streamingChatModel(openAiStreamingChatModel)  // 流式对话模型
    .chatMemory(chatMemory)  // 对话记忆
    .inputGuardrails(new PromptSafetyInputGuardrail())  // 输入安全检查
    .build();
```

**LLM 作用**：
- **模型选择**：根据项目类型选择不同的 LLM 模型
  - Vue 项目：使用推理模型（支持工具调用）
  - HTML/多文件：使用流式对话模型（直接返回代码）
- **工具注册**：为 Vue 项目注册文件操作工具，让 LLM 能够创建和修改文件
- **安全防护**：通过输入护轨（Input Guardrail）过滤恶意输入

---

### 阶段三：LLM 代码生成（核心阶段）

这是 LLM 发挥核心作用的阶段，根据不同的代码生成类型，LLM 采用不同的策略。

#### 3.1 HTML 单文件生成模式

**LLM 工作流程**：

1. **接收系统提示词**
   - 从 `prompt/codegen-html-system-prompt.txt` 加载系统提示词
   - 提示词定义了：
     - LLM 的角色定位（资深 Web 前端开发专家）
     - 技术约束（只能使用 HTML、CSS、原生 JavaScript）
     - 输出格式要求（必须包含 ````html` 代码块）
     - 代码质量要求（响应式、代码整洁、有注释）

2. **接收用户消息**
   - 用户的需求描述（如"创建一个个人博客网站"）
   - 可能包含历史对话上下文（如果是修改请求）

3. **LLM 推理生成**
   - LLM 根据系统提示词和用户需求进行推理
   - 生成完整的 HTML 代码（包含内联 CSS 和 JavaScript）
   - 确保代码符合所有约束条件

4. **流式返回**
   - 使用 `Flux<String>` 流式返回代码片段
   - 前端实时接收并显示生成进度

**LLM 的核心作用**：
- **理解需求**：将自然语言需求转换为代码实现
- **代码生成**：生成符合规范的 HTML 代码
- **约束遵循**：确保代码符合技术约束（无外部依赖、响应式设计等）

**示例系统提示词约束**：
```
- 技术栈: 只能使用 HTML、CSS 和原生 JavaScript
- 禁止外部依赖: 绝对不允许使用任何外部 CSS 框架、JS 库
- 独立文件: 所有 CSS 和 JS 必须内联在 HTML 中
- 响应式设计: 必须在桌面和移动设备上良好显示
```

#### 3.2 多文件生成模式（HTML + CSS + JS）

**LLM 工作流程**：

1. **接收系统提示词**
   - 从 `prompt/codegen-multi-file-system-prompt.txt` 加载
   - 要求 LLM 生成分离的 HTML、CSS、JS 文件

2. **LLM 生成多文件代码**
   - LLM 生成包含多个代码块的响应
   - 每个代码块标记为 ````html`、````css`、````javascript`

3. **流式返回**
   - 实时推送代码片段到前端

**LLM 的核心作用**：
- **代码分离**：理解需要生成多个文件
- **结构规划**：合理规划 HTML、CSS、JS 的代码结构
- **文件组织**：确保代码块正确标记，便于后续解析

#### 3.3 Vue 项目生成模式（工具调用）

**这是 LLM 最复杂的应用场景，展示了 LLM 的自主规划和执行能力。**

**LLM 工作流程**：

1. **接收系统提示词**
   - 从 `prompt/codegen-vue-project-system-prompt.txt` 加载
   - 详细的项目结构要求、技术栈约束、文件完整性要求

2. **LLM 自主规划**
   - LLM 首先分析用户需求
   - 规划需要创建哪些文件（package.json、vite.config.js、src/main.js、src/App.vue 等）
   - 确定项目的整体架构

3. **工具调用执行**
   - LLM 自主决定调用哪些工具
   - 使用 `FileWriteTool` 创建文件：
     ```
     writeFile("package.json", "{...package.json内容...}")
     writeFile("vite.config.js", "{...vite配置...}")
     writeFile("src/main.js", "{...入口文件...}")
     writeFile("src/App.vue", "{...根组件...}")
     ```
   - 可以调用 `FileReadTool` 读取已创建的文件
   - 可以调用 `FileModifyTool` 修改文件内容

4. **多轮工具调用**
   - LLM 可以连续调用多次工具（最多 30 次）
   - 每次工具调用后，LLM 会收到执行结果
   - 根据结果决定下一步操作

5. **实时反馈**
   - 工具调用信息实时推送到前端
   - 用户可以看到 LLM 正在创建哪些文件

**LLM 的核心作用**：
- **项目规划**：理解需求，规划项目结构
- **自主决策**：决定创建哪些文件、文件内容是什么
- **工具使用**：自主调用工具创建和修改文件
- **错误处理**：如果工具调用失败，LLM 可以调整策略
- **完整性保证**：确保所有文件都正确创建，标签都正确闭合

**工具调用示例**：
```
用户：创建一个个人博客网站

LLM 思考：
1. 需要创建 Vue 项目
2. 需要 package.json、vite.config.js
3. 需要路由配置（首页、关于、博客列表）
4. 需要多个 Vue 组件

LLM 执行：
→ writeFile("package.json", "...")
→ writeFile("vite.config.js", "...")
→ writeFile("src/main.js", "...")
→ writeFile("src/router/index.js", "...")
→ writeFile("src/App.vue", "...")
→ writeFile("src/pages/Home.vue", "...")
→ writeFile("src/pages/About.vue", "...")
→ writeFile("src/pages/Blog.vue", "...")
```

**关键特性**：
- **上下文感知**：LLM 知道已经创建了哪些文件
- **依赖管理**：确保文件之间的引用关系正确
- **完整性检查**：确保每个文件的内容完整（特别是 Vue 文件的标签闭合）

---

### 阶段四：代码解析（HTML/多文件模式）

**位置**：`CodeParserExecutor.executeParser()`

**流程**：

1. **HTML 解析**（`HtmlCodeParser`）
   - 使用正则表达式提取 ````html` 代码块
   - 如果找不到代码块，将整个内容作为 HTML

2. **多文件解析**（`MultiFileCodeParser`）
   - 分别提取 ````html`、````css`、````javascript` 代码块
   - 解析为 `MultiFileCodeResult` 对象

**LLM 作用**：此阶段 LLM 不参与，是纯代码解析逻辑。

---

### 阶段五：代码保存

**位置**：`CodeFileSaverExecutor.executeSaver()`

**流程**：

1. **HTML 模式**
   - 保存为 `tmp/code_output/html_{appId}/index.html`

2. **多文件模式**
   - 保存为：
     - `tmp/code_output/multi_file_{appId}/index.html`
     - `tmp/code_output/multi_file_{appId}/style.css`
     - `tmp/code_output/multi_file_{appId}/script.js`

3. **Vue 项目模式**
   - 文件已通过工具调用直接写入，无需额外保存

**LLM 作用**：此阶段 LLM 不参与，是文件系统操作。

---

### 阶段六：项目构建（仅 Vue 项目）

**位置**：`VueProjectBuilder.buildProject()`

**流程**：

1. **执行 `npm install`**
   - 安装项目依赖
   - 超时时间：5 分钟

2. **执行 `npm run build`**
   - 构建生产版本
   - 生成 `dist` 目录

3. **验证构建结果**
   - 检查 `dist` 目录是否生成
   - 验证构建是否成功

**LLM 作用**：此阶段 LLM 不参与，是构建工具执行。

---

## 三、LLM 在不同模式下的对比

| 特性 | HTML 模式 | 多文件模式 | Vue 项目模式 |
|------|----------|-----------|-------------|
| **LLM 模型** | 流式对话模型 | 流式对话模型 | 推理模型（支持工具调用） |
| **输出方式** | 直接返回代码字符串 | 直接返回代码字符串 | 通过工具调用创建文件 |
| **LLM 决策** | 生成完整 HTML | 生成多个代码块 | 自主规划项目结构 |
| **文件创建** | 系统解析后保存 | 系统解析后保存 | LLM 直接调用工具创建 |
| **复杂度** | 低 | 中 | 高 |
| **灵活性** | 低 | 中 | 高（可以读取、修改文件） |

---

## 四、LLM 的核心价值

### 1. 自然语言理解
- **需求理解**：将用户的自然语言描述转换为具体的代码实现
- **上下文理解**：理解多轮对话的上下文，支持增量修改

### 2. 代码生成能力
- **代码编写**：生成符合规范的 HTML、CSS、JavaScript、Vue 代码
- **架构设计**：为 Vue 项目设计合理的文件结构和组件组织

### 3. 约束遵循
- **技术约束**：严格遵守系统提示词中的技术约束（无外部依赖、响应式设计等）
- **格式约束**：确保输出格式符合要求（代码块标记、文件完整性等）

### 4. 自主规划（Vue 项目）
- **项目规划**：自主决定需要创建哪些文件
- **工具调用**：自主决定何时调用哪个工具
- **错误恢复**：工具调用失败时调整策略

### 5. 质量保证
- **代码完整性**：确保文件标签正确闭合
- **代码规范性**：遵循最佳实践和编码规范
- **功能完整性**：确保生成的功能符合用户需求

---

## 五、关键技术点

### 1. 系统提示词（System Prompt）

系统提示词是指导 LLM 行为的关键，包含：
- **角色定义**：告诉 LLM 它是什么角色（前端专家、架构师等）
- **任务描述**：明确 LLM 需要完成什么任务
- **技术约束**：限制 LLM 只能使用哪些技术
- **输出格式**：规定 LLM 的输出格式
- **质量要求**：代码质量、完整性要求

**示例**（HTML 模式）：
```
你是一位资深的 Web 前端开发专家，精通 HTML、CSS 和原生 JavaScript。
你的任务是根据用户提供的网站描述，生成一个完整、独立的单页面网站。
约束: 只能使用 HTML、CSS 和原生 JavaScript，禁止外部依赖...
```

### 2. 对话记忆（Chat Memory）

- **作用**：让 LLM 记住之前的对话内容
- **实现**：使用 Redis 持久化存储
- **隔离**：每个应用有独立的对话上下文
- **加载**：每次创建 AI 服务时，从数据库加载历史对话

### 3. 工具调用（Tool Calling）

- **原理**：LLM 可以调用预定义的工具函数
- **工具类型**：
  - `FileWriteTool`：写入文件
  - `FileReadTool`：读取文件
  - `FileModifyTool`：修改文件
  - `FileDeleteTool`：删除文件
  - `FileDirReadTool`：读取目录
- **优势**：让 LLM 能够执行实际操作，而不仅仅是生成文本

### 4. 流式输出（Streaming）

- **实现**：使用 `Flux<String>` 或 `TokenStream`
- **优势**：实时反馈生成进度，提升用户体验
- **应用**：所有代码生成都支持流式输出

### 5. 输入安全检查（Input Guardrail）

- **作用**：过滤恶意输入，防止提示词注入攻击
- **实现**：`PromptSafetyInputGuardrail`
- **检查项**：
  - 输入长度限制（1000 字）
  - 敏感词检测
  - 注入攻击模式检测

---

## 六、完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户输入提示词                            │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  阶段一：请求处理                                            │
│  - 参数校验                                                  │
│  - 权限校验                                                  │
│  - 保存用户消息                                              │
│  - 任务去重                                                  │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  阶段二：AI 服务初始化                                       │
│  - 创建对话记忆（Redis）                                     │
│  - 加载历史对话                                              │
│  - 根据类型配置 LLM：                                        │
│    • Vue: 推理模型 + 工具调用                               │
│    • HTML/多文件: 流式对话模型                              │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  阶段三：LLM 代码生成 ⭐ 核心阶段                            │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │ HTML 模式                                          │    │
│  │ 1. LLM 接收系统提示词 + 用户需求                   │    │
│  │ 2. LLM 生成完整 HTML 代码                         │    │
│  │ 3. 流式返回代码片段                                │    │
│  └────────────────────────────────────────────────────┘    │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │ 多文件模式                                         │    │
│  │ 1. LLM 接收系统提示词 + 用户需求                   │    │
│  │ 2. LLM 生成 HTML/CSS/JS 代码块                    │    │
│  │ 3. 流式返回代码片段                                │    │
│  └────────────────────────────────────────────────────┘    │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │ Vue 项目模式（工具调用）                            │    │
│  │ 1. LLM 接收系统提示词 + 用户需求                   │    │
│  │ 2. LLM 规划项目结构                                │    │
│  │ 3. LLM 调用工具创建文件：                           │    │
│  │    → writeFile("package.json", "...")             │    │
│  │    → writeFile("src/App.vue", "...")              │    │
│  │    → writeFile("src/pages/Home.vue", "...")      │    │
│  │ 4. 实时推送工具调用信息                            │    │
│  └────────────────────────────────────────────────────┘    │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  阶段四：代码解析（HTML/多文件模式）                         │
│  - HtmlCodeParser: 提取 HTML 代码块                        │
│  - MultiFileCodeParser: 提取 HTML/CSS/JS 代码块            │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  阶段五：代码保存                                            │
│  - HTML: 保存为 index.html                                  │
│  - 多文件: 保存为 index.html, style.css, script.js          │
│  - Vue: 文件已通过工具调用创建                              │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  阶段六：项目构建（仅 Vue 项目）                             │
│  - npm install: 安装依赖                                    │
│  - npm run build: 构建项目                                  │
│  - 验证 dist 目录                                          │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  保存对话历史到数据库                                        │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  返回流式响应到前端                                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 七、LLM 发挥作用的总结

### 1. 需求理解阶段
- **输入**：用户的自然语言描述
- **LLM 作用**：理解用户意图，提取关键需求
- **输出**：结构化的需求理解

### 2. 代码生成阶段
- **输入**：系统提示词 + 用户需求 + 历史对话
- **LLM 作用**：
  - **HTML/多文件模式**：直接生成代码字符串
  - **Vue 项目模式**：规划项目结构，调用工具创建文件
- **输出**：代码或文件创建操作

### 3. 代码质量保证
- **LLM 作用**：
  - 遵循技术约束（无外部依赖、响应式设计等）
  - 确保代码完整性（标签闭合、文件完整）
  - 遵循编码规范（代码整洁、有注释）

### 4. 上下文管理
- **LLM 作用**：
  - 记住历史对话内容
  - 理解多轮对话的上下文
  - 支持增量修改（"把标题改成红色"）

---

## 八、技术亮点

### 1. 多模式支持
- 同一套系统支持三种不同的代码生成模式
- 根据项目类型智能选择最适合的生成策略

### 2. 工具调用机制
- Vue 项目通过工具调用实现自主文件创建
- LLM 可以读取、修改已创建的文件，实现复杂项目生成

### 3. 对话记忆管理
- 每个应用独立的对话上下文
- 支持多轮对话和增量修改

### 4. 流式输出
- 实时反馈生成进度
- 提升用户体验

### 5. 安全防护
- 输入安全检查
- 防止提示词注入攻击

---

## 九、未来优化方向

1. **代码质量检查**：生成后自动检查代码质量，发现问题自动修复
2. **智能路由优化**：更准确地根据需求选择生成类型
3. **错误恢复机制**：构建失败时，LLM 自动分析错误并修复
4. **多框架支持**：支持 React、Angular 等其他框架

---

## 十、总结

LLM 在整个代码生成流程中扮演着**核心决策者和执行者**的角色：

1. **理解用户需求**：将自然语言转换为代码实现
2. **生成代码**：根据系统提示词生成符合规范的代码
3. **自主规划**：Vue 项目中自主规划项目结构
4. **工具调用**：通过工具调用执行实际操作
5. **质量保证**：确保代码完整性和规范性

通过精心设计的系统提示词、工具调用机制和对话记忆管理，LLM 能够高效、准确地完成从需求到代码的完整转换。


